---
layout: chapter
title: Building on the foundations of what was already there, but you didn't see yet
previous_page: /6-pattern-matching
next_page: /8-lists-maps-more
---

<h2>Strings, input and output</h2>

<h3>But first: a brief recap</h3>

<p>
  Elixir would be pretty hard to do if you had to write all the code for your programs by yourself. We have already seen that if you want to add, subtract, multiply or divide numbers, Elixir has your back:
</p>

<pre><code>iex> 2 + 4
<span class='console-yellow'>6</span>
iex> 3 - 6
<span class='console-yellow'>-3</span>
iex> 4 * 12345
<span class='console-yellow'>49380</span>
iex> 1234 / 4
<span class='console-yellow'>308.5</span></code></pre>

<p>We also saw that it can run code inside of some other code, through string interpolation:</p>

<pre><code>iex> place = "World"
iex> "Hello #{place}!"
<span class='console-green'>"Hello, World!"</span>
</code></pre>

<p>We saw that it can handle lists:</p>

<pre><code>iex> ["chicken", "beef", "and so on"]
[<span class='console-green'>"chicken"</span>, <span class='console-green'>"beef"</span>, <span class='console-green'>"and so on"</span>]
</code></pre>

<p>And it can also handle maps:</p>

<pre>
<code>iex> person = %{"name" => "Roberto", "age" => "30ish", "gender" => "Male"}
  %{<span class='console-green'>"age"</span> => <span class='console-green'>"30ish"</span>, <span class='console-green'>"gender"</span> => <span class='console-green'>"Male"</span>, <span class='console-green'>"name"</span> => <span class='console-green'>"Roberto"</span>}</code></pre>

<p>
  We also saw that it could remember functions for us:
</p>

<pre><code>iex> greeting = fn (name) -> "Hello, #{name}!" end
<span class='console-yellow'>#Function&lt;6.52032458/1 in :erl_eval.expr/5&gt;</span></code></pre>

<p>
  And in the last chapter we saw that we could do pattern matching:
</p>

<pre><code>iex> %{"name" => name, "age" => age} = %{"name" => "Roberto", "age" => "30ish"}
%{<span class='console-green'>"name"</span> => <span class='console-green'>"Roberto"</span>, <span class='console-green'>"age"</span> => <span class='console-green'>"30ish"</span>}
iex> name
<span class='console-green'>"Roberto"</span>
iex> age
<span class='console-green'>"30ish"</span></code></pre>

<p>
  But what if I told you that it could do more than this simple math, string interpolation, remembering functions and pattern matching? What if I told you that Elixir already provided some functions that used all of the above things to aid you in building your programs if only you had asked to use them?
</p>

<p>
  Well, all you need to do is ask and Elixir will provide.
</p>

<h3>Working with strings</h3>

<h4>Reversing a string</h4>

<p>
  Have you ever wanted to reverse a sentence, but didn't want to type all the different characters yourself? Elixir has a handy function for this called <code>String.reverse</code>. Here it is in action:
</p>

<pre><code>iex> String.reverse("reverse this")
<span class='console-green'>"siht esrever"</span></code></pre>

<p>
  Roberto elicits a noticeable "wooooowww, that's so cool" at this. "What else does Elixir have?", he asks quickly. We'll get to that, Roberto. Let's take the time now to understand what's happening here first.
</p>

<p>
  The functions that Elixir provides are separated into something akin to kitchen drawers or toolboxes, called <em>modules</em>. Whereas in your top kitchen drawer you might have forks, knives, sporks, and spoons (like every sane person's kitchen does), and in another you might have measuring cups, and in another tea towels, in Elixir the functions to work with the different kinds of data are separated into different modules. This makes finding functions to work with particular kinds of data in Elixir very easy.
</p>

<p>
  Here, we're using the <code>reverse</code> function from the <code>String</code> <em>module</em> ("drawer" / "toolbox"). We're passing this <code>String.reverse</code> function one argument, which is a string <code>"reverse this"</code>. This function takes the string and flips it around, producing the reversed string: <code>"siht esrever"</code>.
</p>

<p>
  Note here how we <em>don't</em> need to put a dot between the function name and its arguments, like we had to do with the functions we defined ourselves. You don't need to do this when you're running a function from a module. You only need the dot if you've defined the function and assigned it to a variable. For instance, with our old <code>greeting</code> function:
</p>

<pre><code>iex> greeting = fn (place) -> "Hello, #{place}!" end
<span class='console-yellow'>#Function&lt;6.52032458/1 in :erl_eval.expr/5&gt;</span>
greeting.("world")
</code></pre>

<p>
  When calling the <code>String.reverse</code> function, Elixir knows that it's a function because of that <code>String.</code> prefix. We don't need a dot right after the function name:
</p>

<pre><code>iex> String.reverse("reverse this")
<span class='console-green'>"siht esrever"</span></code></pre>

<h4>Splitting a string</h4>

<p>
  What about if we wanted to split a string into its individual words? For that, we can use the <code>split</code> function:
</p>

<pre><code>iex> String.split("split my string into pieces")
[<span class='console-green'>"split"</span>, <span class='console-green'>"my"</span>, <span class='console-green'>"string"</span>, <span class='console-green'>"into"</span>, <span class='console-green'>"pieces"</span>]</code></pre>

<p>
  We now have a list of the words in the string. We'll see what we could do with such a list a little later in the chapter. For now, let's look at what else is in this <code>String</code> module.
</p>

<h4>Making all the letters of a string uppercase</h4>

<p>
  What about if we wanted to make the computer turn a string into its shouty variant? We can use <code>upcase</code> for this:
</p>

<pre><code>iex> String.upcase("not so quiet any more")
<span class='console-green'>"NOT SO QUIET ANY MORE"</span></code></pre>

<h4>Making all the letters of a string lowercase</h4>

<p>
  At the opposite end of that particular spectrum, there is <code>downcase</code>:
</p>

<pre><code>iex> String.downcase("LOUD TO QUIET")
<span class='console-green'>"loud to quiet"</span></code></pre>

<p>
  So as you can see, the <code>String</code> module has some helpful functions that can help us whenever we need to split a string, turn it all into upper / lower ("down") case. There's plenty more functions in the <code>String</code> module, and we'll see those in due time.
</p>

<p>
  Let's take a look at working with something that we've not worked with before: input and output.
</p>

<h3>Input and output</h3>

<p>
  Input and output are two fundamental things that you'll work with while programming. Programming is all about taking some data as an input and turning it into some form of an output. We've seen this multiple times already with the functions we've defined and used throughout this book. What we'll cover in this section is getting some user input by making our own prompt. We'll then use this user input to output a message which will vary depending on what the user inputs.
</p>

<h4>Making our own prompts</h4>

<p>
  Let's say that we wanted to prompt people for their names and we wanted to prompt them in a way that meant that they didn't have to read Joy of Elixir to understand that strings had to be wrapped in double quotes. Fortunately for us, Elixir has a module that provides us a function to do just this. That module is called <code>IO</code> (Input / Output) and the function is called <code>gets</code>. The name <code>gets</code> means "get string" and it will allow us to do exactly that. Let's see this function in practice:
</p>

<pre><code>iex> name = IO.gets "What is your name?"
What is your name?</code></pre>

<p>
  "Hey what happened to our <code>iex</code> prompt?", Roberto asks. Good question! We're using <code>gets</code> and passing it a string. This string then becomes a new prompt. This prompt is asking us for our name. Let's type in our name and hit enter:
</p>

<pre><code>iex> name = IO.gets "What is your name?"
What is your name? The Reader
<span class='console-green'>"The Reader\n"</span></code></pre>

<p>
  Ok, so there's some output here. But what does it mean? If we check our <code>name</code> variable's contents we'll see that it contains this <code>"The Reader\n"</code> string.
</p>

<pre><code>iex> name
<span class='console-green'>"The Reader\n"</span></code></pre>

<p>
  Roberto continues asking questions: "What's that <code>\n</code> on the end?". That is a <em>new line character</em> and tells the computer that we pressed enter. While the <code>IO.gets</code> function stopped prompting us after we pressed enter, it still kept the enter in case we wanted it too. In this particular case we don't really want that character. We can get rid of it by using another function from the <code>String</code> module, called <code>trim</code>.
</p>

<pre><code>iex> name = String.trim(name)</code>
<span class='console-green'>"The Reader"</span></pre>

<p>
  That's much better! Now we have our name with that pesky new line character suffixed. What <code>String.trim</code> does is remove all the extra spacing from the end of a string, giving us just the important parts.
</p>

<h4>Taking input and making it output</h4>

<p>
  We've now got some input, but what's the point of taking input if you're not going to <em>do</em> anything with it? So let's do something with it! What we'll do with this input is to output a greeting message.
</p>

<p>
  Lets deviate here from using the <code>iex</code> prompt and instead write our code inside one of those Elixir Script (<code>.exs</code>) files we mentioned back at the end of Chapter 5. Let's call this file <code>greet.exs</code> and put this content inside of it:
</p>

<pre><code>name = IO.gets "What is your name?"
age = IO.gets "And what is your age?"

IO.puts "Hello, #{String.trim(name)}! You're #{String.trim(age)}? That's so old!"</code></pre>

<p>
  Well that's a bit sneaky of that <code>IO.puts</code> to just appear out of <em>nowhere</em>!
</p>

<div class='todo'>Finish explanation here</div>

<p>
  We've done a lot of work with strings so far in this chapter. Let's look at lists again and the built-in functions that we can use with them.
</p>
