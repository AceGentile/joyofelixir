---
layout: default
---

<h2>Funky functions</h2>

<p>
  After about half an hour, Roberto re-appears from seemingly nowhere. His computer screen glows with the information he has collected from the crowd. We're not quite sure how long he's been back for, but the moment our attention fixes on him, he speaks: "Okay, so you can represent different... <em>kinds</em> of things in Elixir -- strings, numbers, lists, maps -- but what is the point of doing that at all? What can you <em>do</em> with them? Do I need to write code to work with these different kinds of things all the time? Can the computer remember code too?"
</p>

<p>
  Well Roberto, that was a very clever and completely unintentional segue into this next part of the book. Thank you for doing that.
</p>

<p>
  Yes, in fact you can tell the computer to remember some code too. This saves <em>a lot</em> of typing. Crazy amounts of the stuff. You'll get <em>years</em> of your life back!
</p>

<p>
  Ok, enough chit-chat. Let's look at how to make the computer remember some code:
</p>

<pre><code>iex(21)> greeting = fn (place) -> "Hello, #{place}!" end
<span class='console-yellow'>#Function&lt;6.52032458/1 in :erl_eval.expr/5&gt;</span></code></pre>

<p>
  This is called a <em>function</em> and we can write whatever code we want the computer to remember for later, just like we could tell the computer to remember a string, a number, a list or a map. Elixir code is all about the functions, and now we understand why Wikipedia said it was a "functional" language. It didn't mean that it was functional in the sense that it is operational, but moreso that it uses functions to get things done.
</p>

<p>
  The <code>fn</code> tells the computer we're about to define a function, and the defining-of-the-function doesn't stop until it gets to the <code>end</code>. Just like you wouldn't stop until you got to the end of something -- i.e. a book -- right?
</p>

<p>
  The <code>(place)</code> here defines an <em>argument</em> for the function; think of it like a variable that is only available within this function and not the angry shouting matches that most <code>normal</code> arguments can devolve into. The <code>-></code> tells the computer that we're done defining the arguments for the function, and anything after this but before the <code>end</code> is going to be the code to run.
</p>

<p>
  Once we hit enter at the end of this line, the computer gives us some output to indicate it has accepted our function. It's not the friendliest output, but at least it's something that tells us the computer has done <em>something</em>.
</p>

<p>
  We've assigned our function to the <code>greeting</code> variable and so that's what the computer will remember the function as. "How do we make the computer run that function?", Roberto asks keenly, suddenly impressed about the computer's ability to remember functions. I'm sure you're asking the same thing, dear reader.
</p>

<p>
Well, Roberto (and dearest reader), we need to use some new and exciting code that we've not seen yet:
</p>

<pre>
<code>iex(22)> greeting.("World")
<span class='console-green'>"Hello, World!"</span></code></pre>

<p>
  This is how we make the function run. We run this function by putting a dot after its name. The brackets after this dot represent the argument for the function. This time that we call the function, <code>place</code> will be <code>"World"</code>. But it doesn't always have to be <code>"World"</code>. It can be anything you wish:
</p>

<pre><code>iex(23)> greeting.("Mars")
<span class='console-green'>"Hello, Mars!"</span>
iex(24)> greeting.("Narnia")
<span class='console-green'>"Hello, Narnia!"</span>
iex(25)> greeting.("Motherland")
<span class='console-green'>"Hello, Motherland!"</span></code></pre>

<p>
  Each time we run the function here we give it a new value for <code>place</code>. We don't have to set <code>place</code> ourselves, as the function takes care of that. But what of our <code>place</code> variable from yesteryear (line 9 in <code>iex</code>)? Has that changed?
</p>

<pre><code>iex(26)> place
<span class='console-green'>"World"</span></code></pre>

<p>
  The computer knows that the <code>place</code> from <em>outside</em> the function is different to the place <em>inside</em> the function, and so it keeps the two separate. The computer is smart enough to know that `place` on the outside may not exist and so it shouldn't rely on it being present. The function contains everything it needs to run inside itself.
</p>

<p>
  One more handy thing about functions is that they're not limited to just one argument. You can define a function that accepts as many arguments as you wish:
</p>

<pre>
<code>iex(27)> greeting = fn (name, gender, age) ->
...(27)>   "Hello, #{name}! I see you're a #{gender} and you're #{age} years old."
...(27)> end
<span class='console-yellow'>#Function&lt;18.52032458/3 in :erl_eval.expr/5&gt;</span></code></pre>

<p>
  This function has 3 arguments, and so when we run it we need to give it all three. To do that, we just separate them using a comma, similar to how we separated the items in a list earlier, just without the square brackets (<code>[]</code>) around these arguments.
</p>

<pre>
<code>iex(28)> greeting.("Roberto", "Male", "30ish")
<span class='console-green'>"Hello, Roberto! I see you're a Male and you're 30ish years old!"</span></code></pre>

<p>We can go nuts with the number of arguments that a function is defined with. However, we need to take a modicum of caution when running the functions. If we specify the wrong number of arguments, Elixir will tell us off with big red text:</p>

<pre><code>iex(19)> greeting.("Roberto")
<span class='console-red'>** (BadArityError) #Function&lt;18.52032458/3 in :erl_eval.expr/5&gt;
  with arity 3 called with 1 argument ("Roberto")</span></code></pre>

<p>
  Oh no the computer is angry with us. Well, if the computer felt any emotion from brutal indifference it would <em>probably</em> be some version of angry, or at least disappointed. The computer is reprimanding us: telling us that we caused a `BadArityError` and that means that we had a "&lt;function&gt; with arity 3 called with 1 argument".
</p>

<p>
  "What on earth is an 'arity'?", Roberto asks, clearly flummoxed (and perhaps a bit affronted) by the word. Unlike the computer, Roberto is not brutally indifferent when it comes to these things. After all, Roberto thought he was getting a handle on this Elixir thing.
</p>

<p>
  Arity is a fancy computer term which means "arguments". This error is saying that while the <code>greeting</code> function is defined with 3 arguments ("with arity 3") we're only running ("calling") it with 1 argument. Helpfully, it tells us what arguments we tried to give the function. To avoid the computer reprimanding us we should make sure to call functions with the right number of arguments.
</p>

<h2>Building on the foundations of what was already there, but you didn't see yet</h2>

<p>
  Elixir would be pretty hard to do if you had to write all the code for your programs by yourself. We have already seen that if you want to add, subtract, multiply or divide numbers, Elixir has your back:
</p>

<pre><code>iex(2)> 2 + 4
<span class='console-yellow'>6</span>
iex(3)> 3 - 6
<span class='console-yellow'>-3</span>
iex(4)> 4 * 12345
<span class='console-yellow'>49380</span>
iex(5)> 1234 / 4
<span class='console-yellow'>308.5</span></code></pre>

We also saw that it can run code inside of some other code, through string interpolation:

<pre><code>iex(9)> place = "World"
iex(10)> "Hello #{place}!"
<span class='console-green'>"Hello, World!"</span>
</code></pre>

We saw that it can handle lists:

<pre><code>iex(9)> ["chicken", "beef", "and so on"]
[<span class='console-green'>"chicken"</span>, <span class='console-green'>"beef"</span>, <span class='console-green'>"and so on"</span>]
</code></pre>

And it can also handle maps:

<pre>
<code>iex(19)> person = %{"name" => "Roberto", "age" => "30ish", "gender" => "Male"}
  %{<span class='console-green'>"age"</span> => <span class='console-green'>"30ish"</span>, <span class='console-green'>"gender"</span> => <span class='console-green'>"Male"</span>, <span class='console-green'>"name"</span> => <span class='console-green'>"Roberto"</span>}</code></pre>

We also saw that it could remember functions for us:

<pre><code>iex(11)> greeting = fn (name) -> "Hello, #{name}!" end
<span class='console-yellow'>#Function&lt;6.52032458/1 in :erl_eval.expr/5&gt;</span></code></pre>

<p>
  But what if I told you that it could do more than this simple math, string interpolation and remembering functions? What if I told you that Elixir already provided some functions that you could use to build your programs, if only you had asked to use them?
</p>

<p>
  Well, all you need to do is ask and Elixir will provide.
</p>

<h3>Working with strings</h3>

<p>
  Have you ever wanted to reverse a sentence, but didn't want to type all the different characters yourself? Use <code>String.reverse</code> for this:
</p>

<pre><code>iex(12)> String.reverse("reverse this")
<span class='console-green'>"siht esrever"</span></code></pre>

<p>
  The functions that Elixir provides are separated into something akin to toolboxes, called <em>modules</em>. Whereas in a real toolbox you might have a bunch of screwdrivers, and in another you might have allen keys, and in another spanners, in Elixir the functions to work with the different kinds of data are separated into different modules.
</p>

<p>
  Here, we're using the <code>reverse</code> function from the <code>String</code> <em>module</em> ("toolbox"). We're passing this <code>String.reverse</code> function one argument, which is a string <code>"reverse this"</code>. This function takes the string and flips it around, producing the reversed string: `"siht esrever"`.
</p>

<p>
  Note here how we <em>don't</em> need to put a dot between the function name and its arguments. You don't need to do this when you're running a function from a toolbox.
</p>

<p>
  What about if we wanted to split a string into its individual words? For that, we can use the <code>split</code> function:
</p>

<pre><code>iex(12)> String.split("split my string into pieces")
[<span class='console-green'>"cut"</span>, <span class='console-green'>"my"</span>, <span class='console-green'>"string"</span>, <span class='console-green'>"into"</span>, <span class='console-green'>"pieces"</span>]</code></pre>

<p>
  We now have a list of the words in the string.
</p>

<p>
  What about if we wanted to make the computer turn a string into its shouty variant? We can use <code>upcase</code> for this:
</p>

<pre><code>iex(12)> String.upcase("not so quiet any more")
<span class='console-green'>"NOT SO QUIET ANY MORE"</span></code></pre>

At the opposite end of that particular spectrum, there is `downcase`:

<pre><code>iex(12)> String.downcase("LOUD TO QUIET")
<span class='console-green'>"loud to quiet"</span></code></pre>

So as you can see, the <code>String</code> module has some helpful functions that can help us whenever we need to split a string, turn it all into upper / lower ("down") case.

<h3>Reversing a list</h3>

<p>
  Now how about if we wanted to reverse something else, like this list:
</p>

<pre><code>iex(12)> animals_or_derivatives_of_animals = ["cat", "dog", "cow", "turducken"]</code></pre>

<p>
  We wouldn't reach into the <code>String</code> toolbox to work with a <em>list</em>, because strings are not lists and lists are not strings! Just like we wouldn't reach into the spanner toolbox to work with a screw.
</p>

<p>
  We should reach into the <code>List</code> toolbox instead, right? Let's try that:
</p>

<pre><code>iex(12)> List.reverse(animals_or_derivatives_of_animals)
List.reverse(animals_or_derivatives_of_animals)
<span class='console-red'>** (UndefinedFunctionError) function List.reverse/1 is undefined or private
    (elixir) List.reverse(["cat", "dog", "cow", "turducken"])</span></code></pre>

<p>
  Uh oh, there's that red text again. The computer is telling us that Elixir doesn't know about a function called <code>List.reverse</code>, or the function is "<em>private</em>". The computer (slyly) won't tell us which one of non-existence or privateness it is, but we'll assume the first case here: that the function is undefined.
</p>

<aside>
  <header>Roberto asks: "Hey, what's that `/1` after the function?"</header>

  <p>
    Glad you asked! It's indicating the <em>arity</em> of the function. Elixir functions can not only differ by <em>name</em> but also by the number of arguments that the function takes. This error message is telling us that we tried to call the <code>List.reverse/1</code> function, and if we passed two arguments instead of one it would tell us that we tried to call the <code>List.reverse/2</code> function instead.
  </p>

<pre><code>iex(12)> List.reverse(animals_or_derivatives_of_animals, [1, 2, 3])
List.reverse(animals_or_derivatives_of_animals, [1, 2, 3])
<span class='console-red'>** (UndefinedFunctionError) function List.reverse/2 is undefined or private
    (elixir) List.reverse(["cat", "dog", "cow", "turducken"], [1, 2, 3])</span></code></pre>

<p>A good example of this is the <code>String.split</code> function that we saw earlier. It has two variants, one that takes a single argument (<code>String.split/1</code>) and one that takes two arguments (<code>String.split/2</code>). We only saw the single-argument version before:</p>

<pre><code>iex(12)> String.split("Hello, World!")
[<span class='console-green'>"Hello,"</span>, <span class='console-green'>"World!"</span>]</code></pre>

<p>
  However, if we supply a second argument to this function it behaves differently:
</p>

<pre><code>iex(12)> String.split("Hello, World!", "o")
["Hell", ", W", "rld!"]</code></pre>

<p>
  The second argument to `String.split/2` tells the computer where to split the string. With the single argument version, the computer assumed we wanted to split on the spaces between the words. With the two argument version -- that is, the <code>/2</code> version -- we tell it that we want to split on the <code>"o"</code> character instead.
</p>

<p>
  This is an important distinction to make in Elixir, and so I'll say it again, this time a bit bigger:
</p>

<p style='font-size: 125%;'><strong>Functions not only differ by name, but by the number of arguments that they take.</strong></p>
</aside>

<p>
  Ok, so we've talked about what <code>/1</code> means (Roberto is now deep in thought), so let's talk about why <code>List.reverse/1</code> doesn't exist.
</p>

<p>
  Lists are a type of data in Elixir called an <em>enumerable</em>. Maps are also <em>enumerable</em>. This means that they can be <em>enumerated</em> through, and you can do something which each item in the list or map. For instance, if we were to write out our list on a piece of paper, it might look something like this:
</p>

<ul>
  <li>Cat</li>
  <li>Dog</li>
  <li>Cow</li>
  <li>Turducken</li>
</ul>

<p>
  It's possible to write each item from the list separately from the other items in the list. We could try to do the same thing for a number (like 1,354), but it wouldn't make sense:
</p>

<ul>
  <li>1</li>
  <li>3</li>
  <li>5</li>
  <li>4</li>
</ul>

<p>
  Numbers are not enumerable because it doesn't make sense for them to be, unlike our list. We can go through each of this list of animals one-at-a-time if we wish. Similar to this, we could <em>enumerate</em> through a map. If we were to take one of our maps from earlier...
</p>

<pre><code>%{<span class='console-green'>"name"</span> => <span class='console-green'>"Roberto"</span>, <span class='console-green'>"age"</span> => <span class='console-green'>"30ish"</span>, <span class='console-green'>"gender"</span> => <span class='console-green'>"Male"</span>}</code></pre>

<p>
  ...and write each key and value pair down, they may look something like this:
</p>

<dl>
  <dt><strong>Name</strong></dt><dd>Roberto</dd>
  <dt><strong>Age</strong></dt><dd>30ish</dd>
  <dt><strong>Gender</strong></dt><dd>Male</dd>
</dl>

<p>
  Again, it makes sense for a map to be an enumerable because you can <em>enumerate</em> through each of the key and value pairs in the map.
</p>

<p>
  To perform actions on <em>enumerable</em> things in Elixir, sometimes we need to look in the <code>Enum</code> module / toolbox too. <code>Enum</code> is short for <code>Enumerable</code>, and it's done that way because nobody has the time to write out <code>Enumerable</code> correctly every single time.
</p>

<p>
  We tried looking in the <code>List</code> module to find the <code>reverse/1</code> function so that we could turn our list around but it wasn't there. So let's look in the <code>Enum</code> module instead. Before that, let's get our list in Elixir form again. It's been a while since we've seen it that way:
</p>

<pre><code>iex(12)> animals_or_derivatives_of_animals = ["cat", "dog", "cow", "turducken"]</code></pre>

<p>
  Since we now know that lists are <em>enumerables</em>, and that the <code>List.reverse/1</code> function doesn't exist <em>but</em> we also (now) know that there's an <code>Enum</code> module to work with this sort of thing, we can probably guess that there's going to be an `Enum.reverse/1` function. Let's try it and see:
</p>

<pre><code>iex(12)> Enum.reverse(animals_or_derivatives_of_animals)
[<span class='console-green'>"turducken"</span>, <span class='console-green'>"cow"</span>, <span class='console-green'>"dog"</span>, <span class='console-green'>"cat"</span>]</code></pre>

<p>
  Hooray! We were able to reverse our list.
</p>

<p>
  Roberto emerges from his deep thought trance to ask another question: "Hey, you mentioned before you could <em>enumerate</em> through a list or a map, but you didn't show an example of that. What gives?" You're absolutely right, Roberto. I was too distracted with explaining why <code>List.reverse/1</code> didn't exist to explain how to enumerate through an enumerable. Let's all now take a look at how to do that.
</p>


<h3>Enumerating the enumerables</h3>

<p>
  To appease Roberto (and the masses that he leads), we're going to need to look at how to enumerate through enumerables. What this means is that we're going to get an enumerable (a list or a map) and we're going to go through each of the enumerable's items and do something with them.
</p>

<p>
  Let's start with a list. How about a list of the seasons, just for something different?
</p>

<pre><code>iex(12)> seasons = ["summer", "fall", "winter", "spring"]</code></pre>

<p>
  The names of these seasons should be capitalized because they are nouns, but whoever created this list neglected to capitalize them. Oops! What we should have is a list with proper capitalization:
</p>

<pre><code>iex(12)> seasons = ["Summer", "Fall", "Winter", "Spring"]</code></pre>


<p>
  What we want to do in this case is to enumerate through each item in the list and to capitalize the first letter of each word, leaving all the others as lower case.
</p>


<a href='/3'>Previous</a>

